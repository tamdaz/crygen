{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Crygen is a shard that generates Crystal code. It is inspired by the PHP library nette/php-generator.</p> <p>API documentation: https://crystaldoc.info/github/tamdaz/crygen/main/index.html</p>"},{"location":"#why-crygen","title":"Why Crygen?","text":"<p>Crygen was created to address the need for automated Crystal code generation. By providing an intuitive API, it helps developers avoid repetitive boilerplate and focus on core logic. Whether you are scaffolding new projects, generating code from documentation, or building tools that output Crystal code, Crygen makes it easier to generate Crystal code automatically.</p> <p>Key benefits include:</p> <ul> <li>Consistency: Ensures generated code follows good practices and style guidelines.</li> <li>Productivity: Reduces manual coding effort and speeds up project setup.</li> <li>Extensibility: Easily integrates into custom tools and workflows.</li> <li>Documentation Conversion: Facilitates transforming documentation or code from other languages into Crystal.</li> </ul> <p>This shard can also save time. Many frameworks (such as Symfony, Laravel, Adonis, and others) provide features for rapid code generation, eliminating the need to rewrite everything by hand.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you find any issues or inconsistencies, or have suggestions, feel free to open an issue or submit a pull request on GitHub.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>To install this shard, add it to your <code>shard.yml</code> file:</p> <pre><code>dependencies:\n  crygen:\n    github: tamdaz/crygen\n    version: ~&gt; 1.3.0\n</code></pre> <p>Then run <code>shards install</code>.</p> <p>Once this shard is installed, you have to import crygen in your entrypoint file for example:</p> <pre><code>require \"crygen\"\n\nmodule App\n  VERSION = \"1.0.0\"\n\n  # Here you can generate the Crystal code:\n\n  class_type = CGT::Class.new(\"MyClass\")\n  method_type = CGT::Method.new(\"my_method\", \"String\")\n\n  class_type.add_method(method_type)\n\n  puts class_type.generate\n  # or\n  # puts class_type\n\n  # Output:\n  # class MyClass\n  #   def my_method : String\n  #   end\n  # end\n\n  # You can save the generated code into the .cr file.\n  File.write(\"src/classes/my_class.cr\", class_type)\nend\n</code></pre> <p>Info</p> <p>All classes located in the <code>Crygen::Types</code> (or <code>CGT</code>) namespace inherit from <code>Crygen::Interfaces::GeneratorInterface</code>.</p> <p>Now you can explore the guide to understand how to generate the code.</p>"},{"location":"guide/alias/","title":"Alias","text":"<p>Crygen provides a class to generate an alias. To do this, use <code>Crygen::Types::Alias</code> (here abbreviated as <code>CGT::Alias</code>).</p> <p>This class takes 2 parameters: the alias name and an array of strings which are types name.</p> <pre><code>puts CGT::Alias.new(\"MyAlias\", %w[Foo Bar])\n</code></pre> <p>Output:</p> <pre><code>alias MyAlias = Foo | Bar\n</code></pre>"},{"location":"guide/alias/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Comment</code></li> </ul>"},{"location":"guide/alias/#add-a-comment-on-an-alias","title":"Add a comment on an alias","text":"<p>In addition of creating an alias, you can put a comment.</p> <pre><code>alias_type = CGT::Alias.new(\"MyAlias\", %w[Foo Bar])\nalias_type.add_comment(&lt;&lt;-STR)\nFor example, this is my alias.\nSTR\n</code></pre> <p>Output:</p> <pre><code># For example, this is my alias.\nalias MyAlias = Foo | Bar\n</code></pre> <p>Info</p> <p>Using the heredoc is recommended if you want to write a multiline comment.</p>"},{"location":"guide/annotation/","title":"Annotation","text":"<p>Annotations can be generated thanks to <code>Crygen::Types::Annotation</code> class (here abbreviated as <code>CGT::Annotation</code>).</p> <pre><code>annotation_type = CGT::Annotation.new(\"MyAnnotation\")\nputs annotation_type.generate\n</code></pre> <p>Output:</p> <pre><code>@[MyAnnotation]\n</code></pre>"},{"location":"guide/annotation/#passing-values-as-arguments","title":"Passing values as arguments","text":"<p>Using the <code>#add_arg</code> method, you can add values that will be passed as arguments to the annotation.</p> <pre><code>annotation_type = CGT::Annotation.new(\"MyAnnotation\")\nannotation_type.add_arg(\"1\")\nannotation_type.add_arg(\"Hello world\".dump)\n\nputs annotation_type.generate\n</code></pre> <p>Output:</p> <pre><code>@[MyAnnotation(1, \"Hello world\")]\n</code></pre> <p>In addition, you can name the argument like:</p> <pre><code>annotation_type = CGT::Annotation.new(\"MyAnnotation\")\nannotation_type.add_arg(\"number\", \"1\")\nannotation_type.add_arg(\"text\", \"Hello world\".dump)\n\nputs annotation_type.generate\n</code></pre> <p>Output:</p> <pre><code>@[MyAnnotation(number: 1, text: \"Hello world\")]\n</code></pre> <p>Info</p> <p>If you want to pass the string in the argument, then you have to call the <code>String#dump</code> method.</p> <p>There's an even better way: if you pass values without necessarily naming arguments, you can use the <code>#add_args</code> method:</p> <pre><code>annotation_type = CGT::Annotation.new(\"MyAnnotation\")\nannotation_type.add_args(\"1\", \"true\", \"Hello world\".dump)\n\nputs annotation_type.generate\n</code></pre> <p>Output:</p> <pre><code>@[MyAnnotation(1, true, \"Hello world\")]\n</code></pre>"},{"location":"guide/c-binding/","title":"C binding","text":"<p>You can create a C binding by instantiating the <code>CGT::LibC</code> class (here abbreviated as <code>CGT::LibC</code>) and adding methods to it.</p> <pre><code>libc_type = Crygen::Types::LibC.new(\"C\")\nputs libc_type.generate\n</code></pre> <p>Output: <pre><code>lib C\nend\n</code></pre></p>"},{"location":"guide/c-binding/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Annotation</code></li> </ul>"},{"location":"guide/c-binding/#create-a-binding-with-a-function","title":"Create a binding with a function","text":"<pre><code>libc_type = Crygen::Types::LibC.new(\"C\")\nlibc_type.add_function(\"getch\", \"Int32\")\nputs libc_type.generate\n</code></pre> <p>Output: <pre><code>lib C\n  fun getch : Int32\nend\n</code></pre></p>"},{"location":"guide/c-binding/#create-a-binding-with-a-struct","title":"Create a binding with a struct","text":"<pre><code>libc_type = Crygen::Types::LibC.new(\"C\")\nlibc_type.add_struct(\"Person\", [{\"name\", \"String\"}, {\"age\", \"Int32\"}])\nputs libc_type.generate\n</code></pre> <p>Output: <pre><code>lib C\n  struct Person\n    name : String\n    age : Int32\n  end\nend\n</code></pre></p>"},{"location":"guide/c-binding/#create-a-binding-with-a-union","title":"Create a binding with a union","text":"<pre><code>libc_type = Crygen::Types::LibC.new(\"C\")\nlibc_type.add_union(\"IntOrFloat\", [\n  {\"some_int\", \"Int32\"},\n  {\"some_float\", \"Float64\"}\n])\nputs libc_type.generate\n</code></pre> <p>Output: <pre><code>lib C\n  union IntOrFloat\n    some_int : Int32\n    some_float : Float64\n  end\nend\n</code></pre></p>"},{"location":"guide/class/","title":"Class","text":"<p>To generate a class, use the <code>Crygen::Types::Class</code> class (here abbreviated as <code>CGT::Class</code>).</p> <pre><code>class_type = Crygen::Types::Class.new(\"MyClass\")\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class MyClass\nend\n</code></pre>"},{"location":"guide/class/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Annotation</code></li> <li><code>Crygen::Modules::ClassVar</code></li> <li><code>Crygen::Modules::Comment</code></li> <li><code>Crygen::Modules::InstanceVar</code></li> <li><code>Crygen::Modules::Method</code></li> <li><code>Crygen::Modules::Mixin</code></li> <li><code>Crygen::Modules::Property</code></li> </ul> <pre><code>class_type = CGT::Class.new(\"MyClass\")\n# You can now use methods from included modules, e.g., add a comment\nclass_type.add_comment(\"This is a sample class\")\nputs class_type\n</code></pre> <p>Output:</p> <pre><code># This is a sample class\nclass MyClass\nend\n</code></pre>"},{"location":"guide/class/#add-several-methods","title":"Add several methods","text":"<p>You can add as many methods as you want to the class.</p> <pre><code>class_type = CGT::Class.new(\"MyClass\")\nmethod_full_name = CGT::Method.new(\"full_name\", \"String\")\nmethod_is_major = CGT::Method.new(\"is_major?\", \"Bool\")\n\nclass_type.add_method(method_full_name)\nclass_type.add_method(method_is_major)\n\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class MyClass\n  def full_name : String\n  end\n\n  def is_major? : Bool\n  end\nend\n</code></pre>"},{"location":"guide/class/#set-the-class-as-abstract","title":"Set the class as abstract","text":"<p>You can set the class as abstract using the <code>#as_abstract</code> method.</p> <pre><code>class_type = CGT::Class.new(\"MyClass\")\nclass_type.as_abstract\nmethod_full_name = CGT::Method.new(\"full_name\", \"String\")\nclass_type.add_method(method_full_name)\n\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>abstract class MyClass\n  def full_name : String\n  end\nend\n</code></pre>"},{"location":"guide/class/#add-mixins-for-a-class","title":"Add mixins for a class","text":"<p>Crygen provides functionalities to add modules you want to import or extend for the classes.</p> <p>For example, you can generate a class and add modules to import or extend using <code>#add_includes</code> and <code>#add_extends</code>.</p> <pre><code>class_type = CGT::Class.new(\"Person\")\nclass_type.add_includes(%w[FirstModule SecondModule])\nclass_type.add_extends(%w[MyExtension AnotherExtension])\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class Person\n  include FirstModule\n  include SecondModule\n  extend MyExtension\n  extend AnotherExtension\nend\n</code></pre> <p>Note</p> <p>For future versions of Crygen, it might be interesting to choose the order (includes first or extends) and also to choose a whitespace between the includes and the extends.</p>"},{"location":"guide/class/#add-instance-variables","title":"Add instance variables","text":"<p>You can add instance variables to the class.</p> <pre><code>class_type = CGT::Class.new(\"User\")\nclass_type.add_instance_var(\"name\", \"String\")\nclass_type.add_instance_var(\"age\", \"Int32\")\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class User\n  @name : String\n  @age : Int32\nend\n</code></pre>"},{"location":"guide/class/#add-class-variables","title":"Add class variables","text":"<p>In addition to instance variables, class variables can also be added.</p> <pre><code>class_type = CGT::Class.new(\"Counter\")\nclass_type.add_class_var(\"count\", \"Int32\")\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class Counter\n  @@count : Int32\nend\n</code></pre>"},{"location":"guide/class/#add-properties","title":"Add properties","text":"<p>For the class, you can add properties: <code>getter</code>, <code>property</code>, <code>setter</code>. Nilable and static properties are also possible.</p> <pre><code>class_type = CGT::Class.new(\"Book\")\nclass_type.add_property(:getter, \"title\", \"String\")\nclass_type.add_property(:nil_property, \"author\", \"String\")\nclass_type.add_property(:setter, \"isbn\", \"String?\")\nclass_type.add_property(:class_getter, \"total_books\", \"Int32\",)\nputs class_type\n</code></pre> <p>Output:</p> <pre><code>class Book\n  getter title : String\n  property? author : String\n  setter isbn : String?\n  class_getter total_books : Int32\nend\n</code></pre>"},{"location":"guide/enum/","title":"Enum","text":"<p>To generate an enumeration, use <code>Crygen::Types::Enum</code> (here abbreviated as <code>CGT::Enum</code>).</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nputs enum_type\n</code></pre> <p>Output:</p> <pre><code>enum Person\nend\n</code></pre>"},{"location":"guide/enum/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Annotation</code></li> <li><code>Crygen::Modules::Comment</code></li> <li><code>Crygen::Modules::Method</code></li> </ul>"},{"location":"guide/enum/#adding-constants","title":"Adding Constants","text":"<p>You can add constants to the enumeration in two ways:</p>"},{"location":"guide/enum/#1-using-the-add_constant-method","title":"1. Using the <code>#add_constant</code> Method","text":"<p>Add each constant individually:</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nenum_type.add_constant(\"Employee\")\nenum_type.add_constant(\"Student\")\nenum_type.add_constant(\"Intern\")\nputs enum_type\n</code></pre>"},{"location":"guide/enum/#2-using-the-add_constants-method","title":"2. Using the <code>#add_constants</code> Method","text":"<p>Add multiple constants at once:</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nenum_type.add_constants(\n  {\"Employee\", \"1\"},\n  {\"Student\", \"2\"},\n  {\"Intern\", \"3\"}\n)\nputs enum_type\n</code></pre> <p>Note</p> <p>When you assign <code>nil</code> to a specific constant, this latter will not have a value.</p> <p>In both cases, the result is the same:</p> <pre><code>enum Person\n  Employee = 1\n  Student = 2\n  Intern = 3\nend\n</code></pre> <p>Info</p> <p>For the next version of crygen, it might be interesting to format the enumeration during the codegen so the assignment and values are in the right place.</p>"},{"location":"guide/enum/#add-the-comments","title":"Add the comments","text":"<p><code>Crygen::Types::Enum</code> provides a method for adding comments on the enumeration</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nenum_type.add_constants(\n  {\"Employee\", \"1\"}, {\"Student\", \"2\"}, {\"Intern\", \"3\"}\n)\n\nenum_type.add_comment(\"This is my enumeration for Person\")\n\nputs enum_type\n</code></pre> <pre><code># This is my enumeration for Person\nenum Person\n  Employee = 1\n  Student = 2\n  Intern = 3\nend\n</code></pre>"},{"location":"guide/enum/#add-the-annotation","title":"Add the annotation","text":"<p>Also, it's possible to add one or many annotation on the enum.</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nenum_type.add_constants(\n  {\"Employee\", \"1\"}, {\"Student\", \"2\"}, {\"Intern\", \"3\"}\n)\n\nannotation_type = CGT::Annotation.new(\"MyAnnotation\")\n\nenum_type.add_comment(\"This is my enumeration for Person\")\nenum_type.add_annotation(annotation_type)\n\nputs enum_type\n</code></pre> <p>Warning</p> <p>If you assign each constant to a value (numbers for example), these will not be double quoted during the code generation.</p> <pre><code># This is my enumeration for Person\n@[MyAnnotation]\nenum Person\n  Employee = 1\n  Student = 2\n  Intern = 3\nend\n</code></pre> <p>Info</p> <p>If you add both a comment and annotations, the comment will appear at the top, followed by the annotation(s) and the code.</p>"},{"location":"guide/enum/#add-a-method-in-an-enumeration","title":"Add a method in an enumeration","text":"<p>You can add one or more methods to an enumeration using the <code>#add_method</code> or <code>#add_methods</code> methods. Each method should be an instance of <code>Crygen::Types::Method</code> (here abbreviated as <code>CGT::Method</code>).</p> <pre><code>enum_type = CGT::Enum.new(\"Person\")\nenum_type.add_constants(\n  {\"Employee\", nil},\n  {\"Student\", nil},\n  {\"Intern\", nil},\n)\n\nmethod_is_student = CGT::Method.new(\"student?\", \"Bool\")\nmethod_is_student.add_body(\"self == Person::Student\")\n\nenum_type.add_method(method_is_student)\n\nputs enum_type\n</code></pre> <p>Output:</p> <pre><code>enum Person\n  Employee\n  Student\n  Intern\n\n  def student? : Bool\n    self == Person::Student\n  end\nend\n</code></pre> <p>You can add several methods at once using <code>add_methods</code>:</p> <pre><code>method_is_employee = CGT::Method.new(\"employee?\", \"Bool\")\nmethod_is_employee.add_body(\"self == Person::Employee\")\n\nmethod_is_intern = CGT::Method.new(\"intern?\", \"Bool\")\nmethod_is_intern.add_body(\"self == Person::Intern\")\n\nenum_type.add_methods(method_is_student, method_is_employee, method_is_intern)\n</code></pre>"},{"location":"guide/macro/","title":"Macro","text":"<p>To generate a macro, use the <code>Crygen::Types::Macro</code> class (here abbreviated as <code>CGT::Macro</code>).</p> <pre><code>macro_type = CGT::Macro.new(\"example\")\nmacro_type.add_arg(\"name\")\nmacro_type.add_body(\"puts {{ name }}\")\nputs macro_type.generate\n</code></pre> <p>Output:</p> <pre><code>macro example(name)\n  puts {{ name }}\nend\n</code></pre>"},{"location":"guide/macro/#generate-a-for-loop-macro","title":"Generate a <code>for</code> loop macro","text":"<pre><code>puts Crygen::Types::Macro.for_loop(\"item\", \"items\") do |str, indent|\n  str &lt;&lt; indent &lt;&lt; \"puts {{ item }}\\n\"\nend\n</code></pre> <p>Output:</p> <pre><code>{% for item in items %}\n  puts {{ item }}\n{% end %}\n</code></pre>"},{"location":"guide/macro/#generate-an-if-condition-macro","title":"Generate an <code>if</code> condition macro","text":"<pre><code>puts Crygen::Types::Macro.if(\"x &gt; 0\") do |str, indent|\n  str &lt;&lt; indent &lt;&lt; 'puts \"positive\"\\n'\nend\n</code></pre> <p>Output:</p> <pre><code>{% if x &gt; 0 %}\n  puts \"positive\"\n{% end %}\n</code></pre>"},{"location":"guide/macro/#generate-an-unless-condition-macro","title":"Generate an <code>unless</code> condition macro","text":"<pre><code>puts Crygen::Types::Macro.unless(\"x &gt; 0\") do |str, indent|\n  str &lt;&lt; indent &lt;&lt; 'puts \"negative or zero\"\\n'\nend\n</code></pre> <p>Output:</p> <pre><code>{% unless x &gt; 0 %}\n  puts \"negative or zero\"\n{% end %}\n</code></pre>"},{"location":"guide/macro/#generate-a-verbatim-block","title":"Generate a <code>verbatim</code> block","text":"<pre><code>puts Crygen::Types::Macro.verbatim do |str, indent|\n  str &lt;&lt; indent &lt;&lt; \"puts 123\\n\"\nend\n</code></pre> <p>Output:</p> <pre><code>{% verbatim do %}\n  puts 123\n{% end %}\n</code></pre>"},{"location":"guide/macro/#recursive-if-unless-and-verbatim-macro","title":"Recursive <code>if</code>, <code>unless</code> and <code>verbatim</code> macro","text":"<p>Also, Crygen allows you to nest one macro block inside another, but the code below will become complex in such cases.</p> <pre><code>puts Crygen::Types::Macro.if(\"x &gt; 0\") do |str, indent|\n  str &lt;&lt; indent &lt;&lt; Crygen::Types::Macro.if(\"y &gt; 0\") do |str2, indent2|\n    str2 &lt;&lt; indent2 &lt;&lt; 'puts \"x and y are positive\"\\n'\n    str2 &lt;&lt; indent\n  end\n  str &lt;&lt; \"\\n\"\nend\n\nputs \"\\n\"\n\nputs Crygen::Types::Macro.unless(\"x &gt; 0\") do |str, indent|\n  str &lt;&lt; indent &lt;&lt; Crygen::Types::Macro.unless(\"y &gt; 0\") do |str2, indent2|\n    str2 &lt;&lt; indent2 &lt;&lt; 'puts \"x and y are negative\"\\n'\n    str2 &lt;&lt; indent\n  end\n  str &lt;&lt; \"\\n\"\nend\n\nputs \"\\n\"\n\nputs Crygen::Types::Macro.verbatim do |str, indent|\n  str &lt;&lt; indent &lt;&lt; Crygen::Types::Macro.verbatim do |str2, indent2|\n    str2 &lt;&lt; indent2 &lt;&lt; 'puts \"nested verbatim\"\\n'\n    str2 &lt;&lt; indent\n  end\n  str &lt;&lt; \"\\n\"\nend\n</code></pre> <p>Output:</p> <pre><code>{% if x &gt; 0 %}\n  {% if y &gt; 0 %}\n    puts \"x and y are positive\"\n  {% end %}\n{% end %}\n\n{% unless x &gt; 0 %}\n  {% unless y &gt; 0 %}\n    puts \"x and y are negative\"\n  {% end %}\n{% end %}\n\n{% verbatim do %}\n  {% verbatim do %}\n    puts \"nested verbatim\"\n  {% end %}\n{% end %}\n</code></pre> <p>Warning</p> <p>If you want to do this recursively, you must carefully manage indentations. For example, the parent <code>verbatim</code> block should use the parameters <code>str</code> and <code>indent</code>. However, the child <code>verbatim</code> block should use its own parameters, such as <code>str2</code> and <code>indent2</code>. You need to differentiate these names to prevent the confusions.</p>"},{"location":"guide/method/","title":"Method","text":"<p>To generate a method, use the <code>Crygen::Types::Method</code> class (here abbreviated as <code>CGT::Method</code>).</p> <pre><code>method_type = CGT::Method.new(\"full_name\", \"String\")\nputs method_type\n</code></pre> <p>Output:</p> <pre><code>def full_name : String\nend\n</code></pre>"},{"location":"guide/method/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Annotation</code></li> <li><code>Crygen::Modules::Arg</code></li> <li><code>Crygen::Modules::Comment</code></li> <li><code>Crygen::Modules::Scope</code></li> </ul>"},{"location":"guide/method/#writing-code-inside-the-method","title":"Writing code inside the method","text":"<p>Once the method is created, you can write code inside it using the <code>#add_body</code> method or by assigning to the <code>body</code> property.</p> <pre><code>method_type = CGT::Method.new(\"full_name\", \"String\")\nmethod_type.body = &lt;&lt;-CRYSTAL\nreturn \"John Doe\"\nCRYSTAL\n</code></pre> <p>Output:</p> <pre><code>def full_name : String\n  return \"John Doe\"\nend\n</code></pre> <p>It is recommended to use a heredoc when writing multiple lines of code.</p>"},{"location":"guide/method/#setting-the-method-as-abstract","title":"Setting the method as abstract","text":"<p>You can set the created method as abstract by calling the <code>#as_abstract</code> method.</p> <pre><code>method_type = CGT::Method.new(\"full_name\", \"String\")\nmethod_type.as_abstract # This method is now abstract\n</code></pre> <p>Output:</p> <pre><code>abstract def full_name : String\n</code></pre> <p>Info</p> <p>If you add code to the method body, this will not be shown after its code generation.</p>"},{"location":"guide/module/","title":"Module","text":"<p>Note</p> <p>All classes in the <code>Crygen::Types</code> namespace implement the <code>Crygen::Interfaces::GeneratorInterface</code> interface. You can add any of these objects to a <code>Crygen::Types::Module</code> instance to generate a module containing them.</p> <p>You can create a module by instantiating the <code>CGT::Module</code> class (here abbreviated as <code>CGT::Module</code>) and adding the code to it.</p> <pre><code>module_type = Crygen::Types::Module.new(\"Folder\")\nputs module_type.generate\n</code></pre> <p>Output: <pre><code>module Folder\nend\n</code></pre></p>"},{"location":"guide/module/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Comment</code></li> </ul>"},{"location":"guide/module/#create-a-module-with-a-class","title":"Create a module with a class","text":"<pre><code>module_type = Crygen::Types::Module.new(\"Folder\")\nmodule_type.add_object(Crygen::Types::Class.new(\"File\"))\nputs module_type.generate\n</code></pre> <p>Output: <pre><code>module Folder\n  class File\n  end\nend\n</code></pre></p>"},{"location":"guide/module/#create-a-module-with-an-enum","title":"Create a module with an enum","text":"<pre><code>enum_type = Crygen::Types::Enum.new(\"Role\", \"Int8\")\nenum_type.add_constant(\"Member\", \"1\")\nenum_type.add_constant(\"Moderator\", \"2\")\nenum_type.add_constant(\"Administrator\", \"3\")\nmodule_type = Crygen::Types::Module.new(\"Folder\")\nmodule_type.add_object(enum_type)\nputs module_type.generate\n</code></pre> <p>Output: <pre><code>module Folder\n  enum Role : Int8\n    Member = 1\n    Moderator = 2\n    Administrator = 3\n  end\nend\n</code></pre></p>"},{"location":"guide/struct/","title":"Struct","text":"<p>You can create a struct by instantiating the <code>CGT::Struct</code> class (here abbreviated as <code>CGT::Struct</code>) and adding methods to it.</p> <pre><code>method_full_name = CGT::Method.new(\"full_name\", \"String\")\nmethod_full_name.add_body(\"John Doe\".dump)\n\nstruct_type = CGT::Struct.new(\"Person\")\nstruct_type.add_method(method_full_name)\n\nputs struct_type.generate\n</code></pre> <p>Output:</p> <pre><code>struct Person\n  def full_name : String\n    \"John Doe\"\n  end\nend\n</code></pre>"},{"location":"guide/struct/#included-modules","title":"Included modules","text":"<ul> <li><code>Crygen::Modules::Annotation</code></li> <li><code>Crygen::Modules::ClassVar</code></li> <li><code>Crygen::Modules::Comment</code></li> <li><code>Crygen::Modules::InstanceVar</code></li> <li><code>Crygen::Modules::Method</code></li> <li><code>Crygen::Modules::Mixin</code></li> <li><code>Crygen::Modules::Property</code></li> </ul>"},{"location":"guide/struct/#adding-multiple-methods","title":"Adding multiple methods","text":"<p>You can add several methods at once using <code>add_methods</code>:</p> <pre><code>method_first_name = CGT::Method.new(\"first_name\", \"String\")\nmethod_first_name.add_body(\"John\".dump)\n\nmethod_last_name = CGT::Method.new(\"last_name\", \"String\")\nmethod_last_name.add_body(\"Doe\".dump)\n\nstruct_type = CGT::Struct.new(\"User\")\nstruct_type.add_methods(method_first_name, method_last_name)\n\nputs struct_type.generate\n</code></pre> <p>Output:</p> <pre><code>struct User\n  def first_name : String\n    \"John\"\n  end\n\n  def last_name : String\n    \"Doe\"\n  end\nend\n</code></pre>"},{"location":"guide/struct/#inheriting-from-an-abstract-struct","title":"Inheriting from an abstract struct","text":"<p>You can specify a parent abstract struct when creating a new struct:</p> <pre><code>struct_type = CGT::Struct.new(\"Employee\", \"AbstractEmployee\")\nputs struct_type.generate\n</code></pre> <p>Output:</p> <pre><code>struct Employee &lt; AbstractEmployee\nend\n</code></pre>"},{"location":"guide/struct/#adding-properties-mixins-and-comments","title":"Adding properties, mixins, and comments","text":"<p>You can also add properties, mixins, and comments to your struct:</p> <pre><code>struct_type = CGT::Struct.new(\"Point\")\nstruct_type.add_property(\"x\", \"Int32\")\nstruct_type.add_property(\"y\", \"Int32\")\nstruct_type.add_mixin(\"JSON::Serializable\")\nstruct_type.add_comment(\"Represents a 2D point.\")\n\nputs struct_type.generate\n</code></pre> <p>Output:</p> <pre><code># Represents a 2D point.\nstruct Point\n  include JSON::Serializable\n\n  property x : Int32\n  property y : Int32\nend\n</code></pre>"},{"location":"releases/v1.1.0/","title":"v1.1.0","text":"<p>With the v1.1.0 Crygen's release, you can add one or more annotations to instance variables and class variables.</p> <pre><code>the_annotation = Crygen::Types::Annotation.new(\"Identity\")\n\nperson_class = Crygen::Types::Class.new(\"Person\")\nperson_class.add_instance_var(\"name\", \"String\", \"John Doe\", the_annotation)\nperson_class.add_class_var(\"age\", \"UInt8\", \"30\", the_annotation)\n\nputs person_class\n</code></pre> <pre><code>class Person\n  @[Identity]\n  @name : String = \"John Doe\"\n  @[Identity]\n  @@age : UInt8 = 30\nend\n</code></pre> <p>If you want to add several annotations, you have to create an array of <code>Crygen::Types::Annotation</code> and pass it into the argument:</p> <pre><code>annotations = [\n  Crygen::Types::Annotation.new(\"Identity\"),\n  Crygen::Types::Annotation.new(\"Sensitive\"),\n]\n\nperson_class = Crygen::Types::Class.new(\"Person\")\nperson_class.add_instance_var(\"full_name\", \"String\", \"John Doe\", annotations)\n\nputs person_class\n</code></pre> <pre><code>class Person\n  @[Identity]\n  @[Sensitive]\n  @full_name : String = \"John Doe\"\nend\n</code></pre> <p>Info</p> <p>In addition, you can directly add the annotation without passing the default value in the argument. <pre><code>-person_class.add_instance_var(\"name\", \"String\", \"John Doe\", the_annotation)\n+person_class.add_instance_var(\"name\", \"String\", the_annotation: the_annotation)\n\n-person_class.add_class_var(\"age\", \"UInt8\", \"30\", the_annotation)\n+person_class.add_class_var(\"age\", \"UInt8\", \"30\", the_annotation: the_annotation)\n</code></pre> However, if you want to add more annotations, you have to use the <code>annotations</code> argument instead of <code>the_annotation</code> <pre><code>-person_class.add_instance_var(\"full_name\", \"String\", \"John Doe\", annotations)\n+person_class.add_instance_var(\"full_name\", \"String\", annotations: annotations)\n\n-person_class.class_var(\"full_name\", \"String\", \"John Doe\", annotations)\n+person_class.class_var(\"full_name\", \"String\", annotations: annotations)\n</code></pre></p>"},{"location":"releases/v1.2.0/","title":"v1.2.0","text":""},{"location":"releases/v1.2.0/#constructor-helper-method","title":"Constructor helper method.","text":"<p>With the v1.2.0 Crygen's release, you can easily add the constructor by calling the <code>#add_initialize</code> helper method.</p> <pre><code>Crygen::Types::Class.new(\"Person\").add_initialize do |method|\n  method.add_arg(\"@x\", \"Int32\")\n  method.add_arg(\"@y\", \"Int32\")\nend\n</code></pre> <p>With the example code above, it is possible to configure the method for adding the arguments and write the body. The block is not required for adding the constructor.</p>"},{"location":"releases/v1.2.0/#generate-nested-classes-and-structs","title":"Generate nested classes and structs","text":"<p>Also, this version provides the new feature for adding the class in the class or the struct in the struct.</p> <pre><code>person_class = Crygen::Types::Class.new(\"Person\")\n\nputs person_class.add_class(person_class)\n</code></pre> <p>Output:</p> <pre><code>class Person\n  class Person\n  end\nend\n</code></pre> <pre><code>point_struct = Crygen::Types::Struct.new(\"Point\")\n\nputs point_struct.add_class(point_struct)\n</code></pre> <p>Output:</p> <pre><code>struct Point\n  struct Point\n  end\nend\n</code></pre> <p>Warning</p> <p>For the moment, it is not possible to add a struct in a class and vice versa. If you need this feature for your project, don't hesitate to create an issue on Github.</p>"},{"location":"releases/v1.2.0/#add-annotations-onto-properties-getters-and-setters","title":"Add annotations onto properties, getters and setters","text":"<pre><code>my_annotation = CGT::Annotation.new(\"JSON::Field\").add_arg(\"key\", \"full_name\".dump)\nCrygen::Types::Class.new(\"Person\").add_property(\n  :property, \"name\", \"String\", annotations: [my_annotation]\n)\n</code></pre> <pre><code>class Person\n  @[JSON::Field(key: \"full_name\")]\n  property name : String\nend\n</code></pre>"},{"location":"releases/v1.2.1/","title":"v1.2.1","text":"<p>This version introduces improvements for code readability and quality, including better spacing and indentation. Internal changes also simplify the codebase and enhance documentation.</p> <p>For a detailed list of changes, see the milestone on GitHub.</p>"},{"location":"releases/v1.2.2/","title":"v1.2.2","text":"<p>This version fixes the bug where spacing weren't added between mixins, properties, instance variables, class variables and nested classes/structs.</p> <p>The <code>Crygen::Utils::Indentation</code> static class has some modifications. Indeed, some method signature have been updated for better managing the indentation. This change is not a breaking change because this static class is mainly used for generators, not for the developers.</p> <p>Finally, the code is refactored to make easier to read.</p> <p>For a detailed list of changes, see the milestone on GitHub.</p>"},{"location":"releases/v1.3.0/","title":"v1.3.0","text":""},{"location":"releases/v1.3.0/#equality-methods","title":"Equality methods","text":"<p>Thanks to @HCLarsen, it is now possible to test the equality of classes, methods, modules and structs. For example:</p> <pre><code>class1 = CGT::Class.new(\"Person\")\n    .add_instance_var(\"name\", \"String\", \"value\")\n\nclass2 = CGT::Class.new(\"Person\")\n    .add_instance_var(\"name\", \"String\", \"value\")\n\nclass2 = CGT::Class.new(\"Person\")\n    .add_instance_var(\"age\", \"Int32\", \"value\")\n\nclass1 == class2 # true\nclass1 == class3 # false\n</code></pre> <p>In brief, <code>class1</code> and <code>class2</code> are the same because they have the same name, type and value's instance variable. However, <code>class1</code> and <code>class3</code> are different because they don't have the same instance variable.</p> <p>You can also compare classes that have their own class variables, their own instance methods, and class methods. Equality methods also applies to methods themselves, modules, and structs.</p>"},{"location":"releases/v1.3.0/#unit-tests","title":"Unit tests","text":"<p>In this project, changes are made to make the code readable and understandable for all contributors. Thanks to the Fluent design pattern, variable name redundancy is eliminated. In addition, a helper has been added to avoid code repetition in many examples for assertions.</p>"},{"location":"releases/v1.3.0/#ameba-configuration","title":"Ameba configuration","text":"<p>For this project, I decided to focus more on adding documentation to understand how it works. The quality of the code is also a factor.</p>"}]}